# --- Rendered client config (when using certificate auth) --- #
# Uses templatefile() instead of the legacy template provider.
# NOTE: Conditional expression is lazy in HCL2, so we can safely reference
# resources that exist only in certificate mode inside the `true` branch.
# `one()` extracts a single element from resources created with count=1.
locals {
  client_vpn_config_rendered = var.authentication_type == "certificate" ? templatefile("${path.module}/client_vpn_config.tpl", {
    # Replace the wildcard prefix in the endpoint DNS name with a stable random pet prefix,
    # so clients see a concrete hostname like "nicepanda.cvpn...".
    vpn_endpoint_dns_name = replace(aws_ec2_client_vpn_endpoint.endpoint.dns_name, "*.", "${random_pet.vpn_prefix.id}.")
    ca_cert               = tls_self_signed_cert.ca.cert_pem
    client_cert           = one(tls_locally_signed_cert.client[*].cert_pem)
    client_key            = one(tls_private_key.client[*].private_key_pem)
  }) : "N/A for federated authentication. Download from AWS self-service portal."
}

# --- ACM Certificate for Server --- #
# This resource imports the dynamically generated server certificate into AWS Certificate Manager.
# It is ALWAYS required for TLS tunnel encryption, regardless of the authentication method.
resource "aws_acm_certificate" "server" {
  private_key       = tls_private_key.server.private_key_pem  # The private key generated by the tls provider
  certificate_body  = tls_locally_signed_cert.server.cert_pem # The server certificate
  certificate_chain = tls_self_signed_cert.ca.cert_pem        # Include the issuing CA to provide a full chain

  lifecycle {
    # Ensures the new certificate is created before the old one is destroyed
    # to avoid dependency errors during updates.
    create_before_destroy = true
  }

  tags = merge(var.tags, {
    Name = "${var.name_prefix}-cvpn-server-cert-${var.environment}"
  })
}

# --- ACM Certificate for CA (Conditional) --- #
# Imports the Root CA certificate. Created ONLY for certificate-based authentication.
# NOTE: Importing the CA with its private key is acceptable for demo/dev; for production,
# consider AWS ACM PCA so the CA private key never leaves a managed service.
resource "aws_acm_certificate" "ca" {
  count = var.authentication_type == "certificate" ? 1 : 0

  private_key      = tls_private_key.ca.private_key_pem # Required for ACM import
  certificate_body = tls_self_signed_cert.ca.cert_pem   # Root CA certificate

  lifecycle {
    create_before_destroy = true
  }

  tags = merge(var.tags, {
    Name = "${var.name_prefix}-cvpn-ca-cert-${var.environment}"
  })
}

# --- CloudWatch Log Group --- #
# Stores connection logs from the Client VPN endpoint.
# NOTE: kms_key_id accepts null; when null, the argument is omitted (no KMS encryption).
resource "aws_cloudwatch_log_group" "client_vpn_logs" {
  name              = "/aws/client-vpn/${var.name_prefix}-${var.environment}" # Standardized naming
  retention_in_days = var.client_vpn_log_retention_days                       # Log retention period
  kms_key_id        = var.kms_key_arn

  tags = merge(var.tags, {
    Name = "${var.name_prefix}-client-vpn-logs-${var.environment}"
  })
}

# --- CloudWatch Log Stream --- #
# A dedicated log stream within the log group for connection logs.
resource "aws_cloudwatch_log_stream" "client_vpn_logs_stream" {
  name           = "connection-logs-stream"
  log_group_name = aws_cloudwatch_log_group.client_vpn_logs.name # Reference to the log group
}

# --- Client VPN Endpoint --- #
# Core resource of the module with dynamic authentication.
resource "aws_ec2_client_vpn_endpoint" "endpoint" {
  description = "Client VPN endpoint for ${var.name_prefix}-${var.environment}"

  # Security group controlling access to the Client VPN endpoint
  security_group_ids = [aws_security_group.client_vpn.id]
  vpc_id             = var.vpc_id

  # Network and IP configuration for connected clients
  client_cidr_block = var.client_vpn_client_cidr_blocks[0] # Address space for clients

  # Conditionally enable the self-service portal
  self_service_portal = var.enable_self_service_portal ? "enabled" : "disabled"

  # Push custom DNS servers to clients upon connection.
  # TIP: Provide at most two IPs; use the VPC DNS (base + 2) to resolve private names.
  dns_servers = var.custom_dns_servers

  # Server certificate is always required for tunnel encryption
  server_certificate_arn = aws_acm_certificate.server.arn

  # --- Dynamic Authentication Block --- #
  # Configures the authentication method based on the `authentication_type` variable.
  authentication_options {
    type = var.authentication_type == "federated" ? "federated-authentication" : "certificate-authentication"

    # These arguments are mutually exclusive; null disables the one not in use.
    root_certificate_chain_arn = var.authentication_type == "certificate" ? aws_acm_certificate.ca[0].arn : null
    saml_provider_arn          = var.authentication_type == "federated" ? var.saml_provider_arn : null
  }

  # Connection logging configuration
  connection_log_options {
    enabled               = true
    cloudwatch_log_group  = aws_cloudwatch_log_group.client_vpn_logs.name         # Destination log group
    cloudwatch_log_stream = aws_cloudwatch_log_stream.client_vpn_logs_stream.name # Destination log stream
  }

  # Security and transport settings
  split_tunnel                  = var.client_vpn_split_tunnel # If true, only specific traffic goes through the VPN
  transport_protocol            = "tcp"                       # TCP/443 eases firewall traversal; UDP may offer higher throughput
  vpn_port                      = 443
  session_timeout_hours         = 24
  disconnect_on_session_timeout = false

  tags = merge(var.tags, {
    Name = "${var.name_prefix}-client-vpn-${var.environment}"
  })

  depends_on = [
    aws_acm_certificate.server,
    # Explicit dependency on aws_acm_certificate.ca is handled via the conditional reference above.
  ]
}

# --- Network Association --- #
# Associates the Client VPN endpoint with one or more subnets in the target VPC.
# NOTE: Each association creates an endpoint ENI in the selected subnet AZ.
resource "aws_ec2_client_vpn_network_association" "vpc" {
  for_each = { for i, subnet_id in var.vpc_subnet_ids : i => subnet_id }

  client_vpn_endpoint_id = aws_ec2_client_vpn_endpoint.endpoint.id
  subnet_id              = each.value # Use each.value to get the subnet ID
}

# --- Authorization Rule --- #
# Authorizes clients to access a specific network (typically the whole VPC CIDR).
# TIP: For federated auth, prefer scoping via access_group_id; otherwise, allow all groups.
resource "aws_ec2_client_vpn_authorization_rule" "vpc_access" {
  client_vpn_endpoint_id = aws_ec2_client_vpn_endpoint.endpoint.id
  target_network_cidr    = var.vpc_cidr
  description            = "Allow all clients to access the VPC"

  access_group_id      = (var.vpn_access_group_id != null && var.vpn_access_group_id != "") ? var.vpn_access_group_id : null
  authorize_all_groups = (var.vpn_access_group_id != null && var.vpn_access_group_id != "") ? false : true

  depends_on = [
    aws_ec2_client_vpn_network_association.vpc
  ]
}

# --- Pet Name for VPN DNS --- #
# Creates a persistent random name (e.g., "nice-panda") to prefix the endpoint DNS.
# Stored in state, so it remains stable across plans (idempotent).
resource "random_pet" "vpn_prefix" {
  length    = 2  # Two-word name like "nice-panda"
  separator = "" # No separator, e.g. "nicepanda"
}



# --- Notes --- #
# 1. General Logic:
#    - Creates a Client VPN endpoint with a configurable authentication method (`authentication_type`).
#    - The server certificate is always present for TLS; CA/client certs are created only in "certificate" mode.
#
# 2. Authentication:
#    - "certificate": Fully automated PKI via the `tls` provider (CA -> server/client).
#    - "federated": Expects an IAM SAML Provider ARN; enable self-service portal for client config retrieval.
#
# 3. Logging:
#    - Connection logs go to a dedicated CloudWatch Log Group (optionally KMS-encrypted).
#
# 4. Routing & Associations:
#    - Each selected subnet is associated with the endpoint (HA across AZs).
#    - A route to `var.vpc_cidr` is automatically added by AWS upon network association.
#
# 5. DNS:
#    - Provide up to two DNS servers; prefer the VPC resolver (base IP + 2 of the VPC CIDR) to resolve private zones.
#
# 6. Security:
#    - Ensure the SG attached to the endpoint allows TCP/443 from the internet and egress as per your policy.
#    - Protect Terraform state (contains private keys in certificate mode). Consider ACM PCA for production CAs.
