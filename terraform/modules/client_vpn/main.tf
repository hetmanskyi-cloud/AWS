# --- ACM Certificate for Server --- #
# This resource imports the dynamically generated server certificate into AWS Certificate Manager.
# It is ALWAYS required for TLS tunnel encryption, regardless of the authentication method.
resource "aws_acm_certificate" "server" {
  private_key      = tls_private_key.server.private_key_pem  # The private key generated by the tls provider
  certificate_body = tls_locally_signed_cert.server.cert_pem # The certificate body generated by the tls provider

  lifecycle {
    # Ensures the new certificate is created before the old one is destroyed
    # to avoid dependency errors during updates.
    create_before_destroy = true
  }

  tags = merge(var.tags, {
    Name = "${var.name_prefix}-cvpn-server-cert-${var.environment}"
  })
}

# --- ACM Certificate for CA (Conditional) --- #
# This resource imports the Root CA certificate. It is created ONLY for certificate-based authentication.
resource "aws_acm_certificate" "ca" {
  # This resource is only needed when using 'certificate' authentication.
  count = var.authentication_type == "certificate" ? 1 : 0

  private_key      = tls_private_key.ca.private_key_pem # The private key for the CA, required for import
  certificate_body = tls_self_signed_cert.ca.cert_pem   # The CA certificate body from the tls provider

  lifecycle {
    create_before_destroy = true
  }

  tags = merge(var.tags, {
    Name = "${var.name_prefix}-cvpn-ca-cert-${var.environment}"
  })
}

# --- CloudWatch Log Group --- #
# This resource creates a log group to store connection logs from the Client VPN endpoint.
resource "aws_cloudwatch_log_group" "client_vpn_logs" {
  name              = "/aws/client-vpn/${var.name_prefix}-${var.environment}" # Log group name with a standard prefix
  retention_in_days = var.client_vpn_log_retention_days                       # Log retention period

  tags = merge(var.tags, {
    Name = "${var.name_prefix}-client-vpn-logs-${var.environment}"
  })
}

# --- CloudWatch Log Stream --- #
# This resource creates a log stream within the previously created log group.
resource "aws_cloudwatch_log_stream" "client_vpn_logs_stream" {
  name           = "connection-logs-stream"
  log_group_name = aws_cloudwatch_log_group.client_vpn_logs.name # Reference to the log group
}

# --- Client VPN Endpoint --- #
# This is the core resource of the module, now with dynamic authentication.
resource "aws_ec2_client_vpn_endpoint" "endpoint" {
  description = "Client VPN endpoint for ${var.name_prefix}-${var.environment}"

  # Security group to control access to the Client VPN endpoint
  security_group_ids = [aws_security_group.client_vpn.id]
  vpc_id             = var.vpc_id

  # Network and IP configuration
  client_cidr_block = var.client_vpn_client_cidr_block # The address space for connecting clients

  # Conditionally enable the self-service portal
  self_service_portal = var.enable_self_service_portal ? "enabled" : "disabled"

  # Push custom DNS servers to the client upon connection.
  dns_servers = var.custom_dns_servers

  # Server certificate is always required for tunnel encryption
  server_certificate_arn = aws_acm_certificate.server.arn

  # --- Dynamic Authentication Block ---
  # Configures the authentication method based on the `authentication_type` variable.
  authentication_options {
    type = var.authentication_type == "federated" ? "federated-authentication" : "certificate-authentication"

    # These arguments are mutually exclusive; null is used to disable the one not in use.
    root_certificate_chain_arn = var.authentication_type == "certificate" ? aws_acm_certificate.ca[0].arn : null
    saml_provider_arn          = var.authentication_type == "federated" ? var.saml_provider_arn : null
  }

  # Connection logging configuration
  connection_log_options {
    enabled               = true
    cloudwatch_log_group  = aws_cloudwatch_log_group.client_vpn_logs.name         # Destination log group for connection data
    cloudwatch_log_stream = aws_cloudwatch_log_stream.client_vpn_logs_stream.name # Destination log stream for connection data
  }

  # Security and transport settings
  split_tunnel                  = var.client_vpn_split_tunnel # Defines if only specified traffic goes through the VPN
  transport_protocol            = "udp"                       # Recommended transport protocol for performance
  vpn_port                      = 443
  session_timeout_hours         = 24
  disconnect_on_session_timeout = false

  tags = merge(var.tags, {
    Name = "${var.name_prefix}-client-vpn-${var.environment}"
  })

  depends_on = [
    aws_acm_certificate.server,
    # The explicit dependency on aws_acm_certificate.ca is no longer needed
    # as it's handled by the conditional reference in `authentication_options`.
  ]
}

# --- Network Association --- #
# Associates the Client VPN endpoint with one or more subnets in the target VPC.
resource "aws_ec2_client_vpn_network_association" "vpc" {
  for_each = { for i, subnet_id in var.vpc_subnet_ids : i => subnet_id }

  client_vpn_endpoint_id = aws_ec2_client_vpn_endpoint.endpoint.id
  subnet_id              = each.value # Use each.value to get the subnet ID
}

# --- Authorization Rule --- #
# Authorizes clients to access a specific network.
resource "aws_ec2_client_vpn_authorization_rule" "vpc_access" {
  client_vpn_endpoint_id = aws_ec2_client_vpn_endpoint.endpoint.id
  target_network_cidr    = var.vpc_cidr
  description            = "Allow all clients to access the VPC"

  # Use a specific group ID if provided (for federated auth), otherwise authorize all.
  access_group_id      = (var.vpn_access_group_id != null && var.vpn_access_group_id != "") ? var.vpn_access_group_id : null
  authorize_all_groups = (var.vpn_access_group_id != null && var.vpn_access_group_id != "") ? false : true
}

# --- Client Config Renderer (Conditional) --- #
# This data source generates the .ovpn file ONLY for certificate-based authentication.
data "template_file" "config" {
  # This data source is only needed when using 'certificate' authentication.
  count = var.authentication_type == "certificate" ? 1 : 0

  template = file("${path.module}/client_vpn_config.tpl")

  vars = {
    vpn_endpoint_dns_name = aws_ec2_client_vpn_endpoint.endpoint.dns_name
    ca_cert               = tls_self_signed_cert.ca.cert_pem
    client_cert           = tls_locally_signed_cert.client[0].cert_pem
    client_key            = tls_private_key.client[0].private_key_pem
  }
}

# --- Notes --- #
# 1. General Logic:
#    - This module creates a Client VPN endpoint with a dynamically configurable authentication method.
#    - The method is controlled by the `authentication_type` variable ("certificate" or "federated").
#
# 2. Authentication Method:
#    - When using "certificate" mode, the module fully automates PKI creation using the `tls` provider.
#    - When using "federated" mode, the module expects the ARN of a pre-configured IAM SAML Provider.
#    - The server certificate is always created as it's required for TLS tunnel encryption in all modes.
#
# 3. Key Features:
#    - Certificate Management: Conditional creation of CA and Client certificates based on the chosen auth method.
#    - Connection Logging: All connection attempts are logged to a dedicated CloudWatch Log Group.
#
# 4. Recommendations:
#    - For production or team use, "federated" authentication with an IdP (Okta, Azure AD) is strongly recommended.
#    - Secure the Terraform state file, as it contains private keys when using certificate authentication.
